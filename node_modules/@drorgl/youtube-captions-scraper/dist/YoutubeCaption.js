"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.YoutubeCaption = void 0;
// import axios from "axios";
const he_1 = __importDefault(require("he"));
const querystring_1 = __importDefault(require("querystring"));
const striptags_1 = __importDefault(require("striptags"));
const xml2js_1 = __importDefault(require("xml2js"));
const crawler_1 = require("./crawler");
/**
 * Youtube Caption Retriever
 *
 * Note: All Requests are locally cached
 * @export
 * @class YoutubeCaption
 */
class YoutubeCaption {
    /**
     * Creates an instance of YoutubeCaption
     * @param {string} videoId - The Youtube VideoId
     * @param {IRequester} requester - the http requester, defaults to SuperAgentRequester instance
     * @memberof YoutubeCaption
     */
    constructor(videoId, requester = YoutubeCaption.defaultRequester) {
        this.videoId = videoId;
        this.requester = requester;
        this._video_info = null;
        this._subtitles = {};
    }
    /**
     * Retrieve a list of Caption Tracks
     *
     * @returns {Promise<ICaptionTrack[]>}
     * @memberof YoutubeCaption
     */
    async getCaptionTracks() {
        const videoInfo = await this.getVideoInfo();
        const parsedUrl = querystring_1.default.parse(videoInfo);
        const player_response = parsedUrl.player_response;
        const playerResponse = JSON.parse(player_response);
        const captions = playerResponse.captions.playerCaptionsTracklistRenderer;
        const captionTracks = captions.captionTracks;
        return captionTracks;
    }
    /**
     * Retrieve Subtitles
     *
     * @param {string} [lang] - language to retrieve, defaults to en
     * @returns {Promise<ISubtitle[]>}
     * @memberof YoutubeCaption
     */
    async getSubtitles(lang) {
        if (!lang) {
            lang = "en";
        }
        if (this._subtitles[lang]) {
            return this._subtitles[lang];
        }
        const captionTracks = await this.getCaptionTracks();
        const captionTrack = captionTracks.find((v) => v.languageCode === lang);
        if (!captionTrack) {
            throw new Error("language not found");
        }
        const transcript = await (await this.requester.get(captionTrack.baseUrl)).toString();
        const result = await this.parseString(transcript);
        const lines = result.transcript.text.map((v) => {
            const decodedHtml = he_1.default.decode(v._);
            return {
                text: striptags_1.default(decodedHtml),
                htmlText: decodedHtml,
                dur: v.$.dur,
                start: v.$.start
            };
        });
        this._subtitles[lang] = lines;
        return this._subtitles[lang];
    }
    /**
     * Retrieve Video Info
     *
     * @private
     * @returns {Promise<string>}
     * @memberof YoutubeCaption
     */
    async getVideoInfo() {
        if (this._video_info) {
            return this._video_info;
        }
        const data = await (await this.requester.get(`https://youtube.com/get_video_info?video_id=${this.videoId}`)).toString();
        this._video_info = data;
        return this._video_info;
    }
    /**
     * Parse and Convert XML string to JSON
     *
     * @private
     * @param {string} xml
     * @returns {Promise<any>}
     * @memberof YoutubeCaption
     */
    parseString(xml) {
        return new Promise((resolve, reject) => {
            xml2js_1.default.parseString(xml, (err, result) => {
                if (err) {
                    return reject(err);
                }
                resolve(result);
            });
        });
    }
}
exports.YoutubeCaption = YoutubeCaption;
YoutubeCaption.defaultRequester = new crawler_1.SuperAgentRequester({});
//# sourceMappingURL=YoutubeCaption.js.map