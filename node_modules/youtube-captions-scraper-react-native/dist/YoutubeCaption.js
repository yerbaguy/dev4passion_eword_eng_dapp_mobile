"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const axios_1 = __importDefault(require("axios"));
const he_1 = __importDefault(require("he"));
const querystring_1 = __importDefault(require("querystring"));
const striptags_1 = __importDefault(require("striptags"));
const xml2js = require("react-native-xml2js");
/**
 * Youtube Caption Retriever
 *
 * Note: All Requests are locally cached
 * @export
 * @class YoutubeCaption
 */
class YoutubeCaption {
    /**
     * Creates an instance of YoutubeCaption
     * @param {string} videoId - The Youtube VideoId
     * @memberof YoutubeCaption
     */
    constructor(videoId) {
        this.videoId = videoId;
        this._video_info = null;
        this._subtitles = {};
    }
    /**
     * Retrieve a list of Caption Tracks
     *
     * @returns {Promise<ICaptionTrack[]>}
     * @memberof YoutubeCaption
     */
    async getCaptionTracks() {
        const videoInfo = await this.getVideoInfo();
        try {
            const parsedUrl = querystring_1.default.parse(videoInfo);
            // console.log(parsedUrl);
            const player_response = parsedUrl.player_response;
            // console.log("player response", player_response);
            const playerResponse = JSON.parse(player_response);
            // console.log("response", playerResponse);
            const captions = playerResponse.captions.playerCaptionsTracklistRenderer;
            const captionTracks = captions.captionTracks;
            return captionTracks;
        }
        catch (e) {
            throw e;
        }
    }
    /**
     * Retrieve Subtitles
     *
     * @param {string} [lang] - language to retrieve, defaults to en
     * @returns {Promise<ISubtitle[]>}
     * @memberof YoutubeCaption
     */
    async getSubtitles(lang) {
        if (!lang) {
            lang = "en";
        }
        if (this._subtitles[lang]) {
            return this._subtitles[lang];
        }
        let captionTracks = [];
        try {
            captionTracks = await this.getCaptionTracks();
        }
        catch (e) {
            throw new Error("Unable to receive tracks");
        }
        const captionTrack = captionTracks.find(v => v.languageCode === lang);
        if (!captionTrack) {
            throw new Error("language not found");
        }
        const { data: transcript } = await axios_1.default.get(captionTrack.baseUrl);
        const result = await this.parseString(transcript);
        const lines = result.transcript.text.map((v) => {
            if (v._ && v.$) {
                const decodedHtml = he_1.default.decode(v._ || "");
                return {
                    text: striptags_1.default(decodedHtml),
                    htmlText: decodedHtml,
                    dur: v.$.dur,
                    start: v.$.start
                };
            }
        }).filter((i) => i !== undefined);
        this._subtitles[lang] = lines;
        return this._subtitles[lang];
    }
    /**
     * Retrieve Video Info as an object
     *
     * @returns {Promise<any>}
     * @memberof YoutubeCaption
     */
    async getVideoInfoObject() {
        const videoInfo = await this.getVideoInfo();
        const info = querystring_1.default.parse(videoInfo);
        const player_response = info.player_response;
        if (player_response) {
            const parsedData = JSON.parse(player_response);
            if (parsedData.videoDetails) {
                return {
                    title: parsedData.videoDetails.title,
                    allowRatings: parsedData.videoDetails.allowRatings,
                    author: parsedData.videoDetails.author,
                    averageRating: parsedData.videoDetails.averageRating,
                    channelId: parsedData.videoDetails.channelId,
                    isCrawlable: parsedData.videoDetails.isCrawlable,
                    isLiveContent: parsedData.videoDetails.isLiveContent,
                    isOwnerViewing: parsedData.videoDetails.isOwnerViewing,
                    isPrivate: parsedData.videoDetails.isPrivate,
                    isUnpluggedCorpus: parsedData.videoDetails.isUnpluggedCorpus,
                    keywords: parsedData.videoDetails.keywords,
                    lengthSeconds: parsedData.videoDetails.lengthSeconds,
                    shortDescription: parsedData.videoDetails.shortDescription,
                    thumbnails: parsedData.videoDetails.thumbnail &&
                        parsedData.videoDetails.thumbnail.thumbnails
                        ? parsedData.videoDetails.thumbnail.thumbnails
                        : [],
                    useCipher: parsedData.videoDetails.useCipher,
                    videoId: parsedData.videoDetails.videoId,
                    viewCount: parsedData.videoDetails.viewCount
                };
            }
        }
        return null;
    }
    /**
     * Retrieve Video Info
     *
     * @private
     * @returns {Promise<string>}
     * @memberof YoutubeCaption
     */
    async getVideoInfo() {
        if (this._video_info) {
            return this._video_info;
        }
        const { data } = await axios_1.default.get(`https://youtube.com/get_video_info?video_id=${this.videoId}`);
        this._video_info = data;
        return this._video_info;
    }
    /**
     * Parse and Convert XML string to JSON
     *
     * @private
     * @param {string} xml
     * @returns {Promise<any>}
     * @memberof YoutubeCaption
     */
    parseString(xml) {
        return new Promise((resolve, reject) => {
            xml2js.parseString(xml, (err, result) => {
                if (err) {
                    return reject(err);
                }
                resolve(result);
            });
        });
    }
}
exports.YoutubeCaption = YoutubeCaption;
//# sourceMappingURL=YoutubeCaption.js.map